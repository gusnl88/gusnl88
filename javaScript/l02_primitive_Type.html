<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>기본형 데이터 타입</title>
</head>
<style>
    @import url("https://fonts.googleapis.com/css?family=Signika+Negative:300,400&display=swap");
    body{
        font-family: "Signika Negative", sans-serif;
    }
    h2{
        text-shadow: 2px 2px 2px gray;
        color: darkgreen;
    }
    b{
        background-color: lightcoral;
        color: white;
    }
    h3{text-shadow: 2px 2px 2px gray;
        color: dodgerblue;

    }
</style>
<body oncontextmenu="return false" onselectstart="return false">
<fieldset>
    <legend><h2>자바스크립트의 기본형 데이터와 타입</h2></legend>
    <h2>자바의 기본형 </h2>
    <ul>
        <li>123 : int</li>
        <li>12312312313l : long</li>
        <li>123.12 : double (8byte)</li>
        <li>true, false : boolean</li>
        <li>byte : byte b=(byte)13;</li>
        <li>short : short b=(short)13333333;</li>
        <li>int : int b=13;</li>
        <li>log : long l = 12312321321l</li>
        <li>float : float f=123.23f</li>
        <li>double : double d=123.23</li>
        <li>char : char c=(0~127)/ 1byte|| '\u1231' , 0x1231 ,'가' 1~4byte</li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>자바스크립트의 기본형 7가지<b>(암기)!!</b></h2></legend>
    <ul>
        <li>number : 자바의 double 과 같은 기본형으로 모든 연산이 가능(123,123.123, NaN, infinity)</li>
        <li>bigint : number 가 가장 정확하게 표현할 수 있는 정수보다 큰수를 표기할 때 사용(12312.....n)</li>
        <li>string : 문자의 배열형태의 자료로 자바의 char[]배열과 같은 타입이다 ("안녕",'',`${변수참조}`)</li>
        <li>boolean : 논리연산의 결과로 true,false 를 나타낸다.</li>
        <li>null :자료가 없다.수로 형변환하면 0으로 취굽</li>
        <li>undefined : 선언되지 않음, 선언되지 않은 상태의 변수를 참조할 때 발생하는 오류를 예방하기 위해 존재(NaN)</li>
        <li>symbol : 고유값을 반환하는 데이터로 Iterable 한 자료의 식별자를 정의할 떄 사용 됨</li>
    </ul>
    <p>*type of : 기본형의 타입을 문자열로 반환하는 연산으로 자료형은 모두 "object"로 반환하고 함수는 "function"으로 반환</p>
</fieldset>
<fieldset>
    <legend><h2>Number 기본형</h2></legend>
    <ul>
        <li>정수 :정수를 선언해도 실수가 된다.</li>
        <li>실수 :8byte 짜리 실수로 java double 과 똑같다.</li>
        <li>NaN : NOT A Number 의 준말로 수로 변환할수 없는 데이터를 수로 변환할때 오류를 발생하지 않으려고 등장!</li>
        <li>Infinity : 무한대</li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>string 문자열</h2></legend>
    <ul>
        <li>"",'',`` 으로 선언 가능</li>
        <li>메모리에 캐릭터 배열의 형태로 저장되어 자료형이지만 자바스크립트에서는 기본형으로 취급한다.</li>
        <li>+(concat() 더하기 연산이 가능</li>
        <li>자바처럼 리터럴하게 선언하면 새로운 문자열을 만들지않고 기존의 문자열을 참조함 "안녕"=="안녕" :true</li>
    </ul>
</fieldset>

<fieldset>
    <legend><h2>숫자 연산자</h2></legend>
    <p>*,/,%,**,+,=,++,--,+=,-=,*=,/=,%=</p>
    <ul>
        <li>+ : 더하기 연산자는 수와 문자열 둘다 연산할 수 있다.
            문자열의 +연산은 string.concat()을 하는 것과 같다.
           예) "a"+"b" == String.concat("a"+"b")
        </li>
        <li>문자열과 수를 + 연산했을때 수를 문자열로 취급한다.</li>
        <li>+연산을 제외한 모든 연산은 문자열을 수로 변환한다.</li>
        <li>문자열의 자동형변환시 문자열이 수가될 수 없으면 NaN이 반환된다.(java NumberFormatException 오류)</li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>비교 연산자</h2></legend>
    <p>이항연산(==,!=,>=,<=,===),단항 (!),(js는 자료형을 비교하는 object.equals()가 없다</p>
    <ul>
        <li>1==1 :
            <script>document.write(1==1)</script>
        </li>
        <li>1=="1.0" :
            <script>document.write(1=="1.0")</script>
            (== 연산에 수가 있으면 문자열을 수로 변환한다.("1"!="1.0"))
        </li>
        <li>1=="1" :
            <script>document.write(1=="1")</script>
        </li>
        <li>1==="1" :
            <script>document.write(1==="1")</script>
           <br> (===는 형변환 없이 비교연산,완전동등비교연산)
        </li>
        <li>"13">=1  :
            <script>document.write("13">=1 )</script>
            <br>(13>=1)
        </li>
        <li>"십삼">=1 :
            <script>document.write("십삼">=1 )</script>
            <br>(NaN>=1)
        </li>
        <li>"십삼"=="십삼" :
            <script>document.write("십삼"=="십삼")</script>
        </li>
        <li>"십삼"==="십삼" :
            <script>document.write("십삼"==="십삼")</script>
        </li>
        <li>"십삼"==new String("십삼") :
            <script>document.write("십삼"==new String("십삼"))</script>
            <br>(new String("십삼")=>"십삼"의 기본값만 참조 후 비교연산
        </li>
        <li>"십삼"===new String("십삼") :
            <script>document.write("십삼"===new String("십삼"))</script>
            <br>(기본형과 자료형을 비교했기 때문에 false)
            <br>(java에서는 다른이유로 false:둘다 자료형이기 때문에 true이나 자료형은 ==으로 비교연산할 수 없다.)
            <br>(java의 String은 리터럴하게 선언하면 같은 값을 참조하기 때문)
        </li>
        <li><u> 리터럴한 선언법</u> : 보이는 그대로가 데이터가 된다.
            <br>(대부분의 프로그래밍 언어에서 기본형 데이터는 리터럴하게 선언한다).

            <script>document.write()</script>
        </li>
        <li>
            <script>document.write()</script>
        </li>

    </ul>

</fieldset>

<fieldset>
    <legend><h2>기본형과 랩퍼클래스와 자동완성!</h2></legend>
    <ul>
        <li>랩퍼 클래스 Number BigInt, String ,Boolean 기본데이터 타입을 도와주는 필드의 집합</li>
        <li>기본형에서 바로 랩퍼 클래스의 필드를 접근하는 것처럼 사용가능하다. (자동완성)</li>
        <li>문자열도 char[]의 형태로 메모리에 저장되어 있기때문에 랩퍼클레스 string 에서 필드를 호출한다.</li>
        <li></li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>Number 랩퍼클래스의 유용한 함수들</h2></legend>
    <ul>
        <li>isNaN("십") : 매개변수가 수로 형변환 했을때 NaN인지 확인 (불가능:true , 가능:false)</li>
        <li>Number.isNaN(NaN,"십"*3) :매개변수 수로 형변환하지 않고 NaN 인지만 확인(NaN : true)</li>
        <li>isInfinity():</li>
        <li>toExponential(자리수): </li>
        <li>toFixed(자리수):</li>
        <li>toPrecision(총길이):</li>
        <li>Number("문자열")</li>
        <li>parseFloat("문자열")</li>
        <li>parseInt("문자열")</li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>Math 의 유용한 함수들</h2></legend>
    <ul>
        <li>Math.round(실수) : </li>
        <li>Math.ceil(실수)</li>
        <li>Math.floor(실수)</li>
        <li>Math.trunc(실수)</li>
        <li>Math.pow(a,n)</li>
        <li>Math.sqrt(수)</li>
        <li>Math.abs(수)</li>
        <li>Math.min(수,수,...),Math.max(수,수,...)</li>
        <li>Math.random()</li>
    </ul>
</fieldset>
<fieldset>
    <legend><h2>String 의 랩퍼클래스의 유용한 함수들</h2></legend>
    <ul>
        <li>slice</li>
        <li>substring</li>
        <li>substr</li>
        <li>replace</li>
        <li>replaceAll</li>
        <li>toUpperCase</li>
        <li>toLowerCase</li>
        <li>trim</li>
        <li>charAt</li>
        <li>charCodeAt</li>
        <li>split</li>
        <li>concat</li>
        <li>indexOf</li>
        <li>lastIndexOf</li>
        <li>search</li>
        <li>match</li>
        <li>matchAll</li>
        <li>includes</li>
        <li>startsWith</li>
        <li>endsWith</li>
    </ul>
</fieldset>
<script>
    let num;

    console.log(num + ":" + (typeof num)); //type of 는 데이터 타입을 문자열로 반환
    num = 13;
    console.log(num + ":" + (typeof num));
    num = "십삼";
    console.log(num + ":" + (typeof num));
    num = true;
    console.log(num + ":" + (typeof num));
    //num=Number("십삼");  //Number : 문자열을 수로 형변환 (자바의 INTEGER)
    console.log((13 - "일") + ":" + (typeof num)); //NaN : 수와 관련된 오류를 표시
    console.log((1 / 0.000000000000000) + ":" + (typeof num)); //NaN : 수와 관련된 오류를 표시

    let bigInt = 1231231232131313213213232132132132131321321321321321321312321321321;
    console.log(bigInt + ":" + (typeof bigInt)); // number 부동소수점으로 표기
    bigInt = 12312312321313132132132321321321322222222222222222222n;//큰 정수 bigint
    console.log(bigInt + ":" + (typeof bigInt));

    let string = "안녕";
    console.log(string + " : " + (typeof string)); // char [] = {'안','녕'};
    string = String("안녕");
    console.log(string + " : " + (typeof string)); //string s="안녕"or new String("안녕");
    string = '안녕~';
    console.log(string + " : " + (typeof string));
    let name = "경민";
    string = `안녕하세요! ${name} 씨~ `;// `` 벡틱으로 선언하는 문자열은 표현식으로 +연산을 대신할 수 있다.
    console.log(string + " : " + (typeof string));

    //기본형의 랩퍼 클래스와 자동완성!
    //기본형에 필드가 없지만 마치 자료형인 것처럼 사용가능하다

    let i = 1000.123123;

    console.log("i.toFixed(4) :" + i.toFixed(4))//Number.toFixed  :4자리까지 출력하고 반올림
    console.log("new Number(i).toFixed(4)" + Number(i).toFixed(4)) //원래모습
    //new Interface(){ @Override void sum(){}} ->     ()-{}
    //js의 자동형변환에 자동완성이 이해를 더욱 어렵게 할 수 있다. -> 이해하면 코드가 줄고 생산성이 높아진다.

    console.log(`0.1+0.2= ${0.1 + 0.2}`);

    //NaN
    let input = "십";
    console.log(`NaN==NaN : ${NaN == NaN}`)
    console.log(`Number.parseInt("십")==NaN : ${Number.parseInt(input) == NaN}`)
    console.log(`isNaN("십") : ${isNaN(input)}`);//"십이" 숫자로 형변환 불가능한가?
    console.log(`Number.isNaN("십")==NaN : ${Number.isNaN(input)}`);//date가 NaN인지만 확인
    console.log(`Number.parseint(parseInt("십"))==NaN : ${Number.isNaN(parseInt(input))}`);

    //자바스크립트는 문자를 수와 연산할때 꼭 수로 형변환 한다.(+연산은 제외 한다)
    console.log("1"+1);//->11 (+ 더하기 연산은 문자열을 수로 형변환하지 않고 수를 문자열로 만들고 연산한다.)
    console.log("1"-1);//1-1=0 (-,*,/,%,** 문자열이 연산할 수 없기 떄문에 꼭 문자열을 수로 형변환한다.)
    console.log("일"+1);//NaN-1 => NaN (수만 가능한 연산을 할때 js는 문자열을 수로 형변환하는데 이때 NaN가 발생한다.)
    console.log(parseInt("1")+1);
    let z=10;
    console.log(++z/2);
    z=10;
    console.log(z++/2)
    z=10;
    console.log(z++);

</script>

</body>
</html>